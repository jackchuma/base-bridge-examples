/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedAppendToCallBufferInstruction,
  type ParsedAppendToProveBufferDataInstruction,
  type ParsedAppendToProveBufferProofInstruction,
  type ParsedBridgeCallBufferedInstruction,
  type ParsedBridgeCallInstruction,
  type ParsedBridgeSolInstruction,
  type ParsedBridgeSolWithBufferedCallInstruction,
  type ParsedBridgeSplInstruction,
  type ParsedBridgeSplWithBufferedCallInstruction,
  type ParsedBridgeWrappedTokenInstruction,
  type ParsedBridgeWrappedTokenWithBufferedCallInstruction,
  type ParsedCloseCallBufferInstruction,
  type ParsedCloseProveBufferInstruction,
  type ParsedInitializeCallBufferInstruction,
  type ParsedInitializeInstruction,
  type ParsedInitializeProveBufferInstruction,
  type ParsedProveMessageBufferedInstruction,
  type ParsedProveMessageInstruction,
  type ParsedRegisterOutputRootInstruction,
  type ParsedRelayMessageInstruction,
  type ParsedSetAdjustmentDenominatorInstruction,
  type ParsedSetBlockIntervalRequirementInstruction,
  type ParsedSetGasCostScalerDpInstruction,
  type ParsedSetGasCostScalerInstruction,
  type ParsedSetGasFeeReceiverInstruction,
  type ParsedSetGasPerCallInstruction,
  type ParsedSetGasTargetInstruction,
  type ParsedSetMaxCallBufferSizeInstruction,
  type ParsedSetMinimumBaseFeeInstruction,
  type ParsedSetOracleSignersInstruction,
  type ParsedSetPartnerOracleConfigInstruction,
  type ParsedSetPauseStatusInstruction,
  type ParsedSetWindowDurationInstruction,
  type ParsedTransferGuardianInstruction,
  type ParsedWrapTokenInstruction,
} from '../instructions';

export const BRIDGE_PROGRAM_ADDRESS = '' as Address<''>;

export enum BridgeAccount {
  Bridge,
  CallBuffer,
  IncomingMessage,
  OutgoingMessage,
  OutputRoot,
  ProveBuffer,
}

export function identifyBridgeAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): BridgeAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([231, 232, 31, 98, 110, 3, 23, 59])
      ),
      0
    )
  ) {
    return BridgeAccount.Bridge;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([134, 143, 168, 251, 163, 216, 180, 113])
      ),
      0
    )
  ) {
    return BridgeAccount.CallBuffer;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([30, 144, 125, 111, 211, 223, 91, 170])
      ),
      0
    )
  ) {
    return BridgeAccount.IncomingMessage;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([150, 255, 197, 226, 200, 215, 31, 29])
      ),
      0
    )
  ) {
    return BridgeAccount.OutgoingMessage;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([11, 31, 168, 201, 229, 8, 180, 198])
      ),
      0
    )
  ) {
    return BridgeAccount.OutputRoot;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([78, 160, 227, 163, 97, 140, 40, 149])
      ),
      0
    )
  ) {
    return BridgeAccount.ProveBuffer;
  }
  throw new Error(
    'The provided account could not be identified as a bridge account.'
  );
}

export enum BridgeInstruction {
  AppendToCallBuffer,
  AppendToProveBufferData,
  AppendToProveBufferProof,
  BridgeCall,
  BridgeCallBuffered,
  BridgeSol,
  BridgeSolWithBufferedCall,
  BridgeSpl,
  BridgeSplWithBufferedCall,
  BridgeWrappedToken,
  BridgeWrappedTokenWithBufferedCall,
  CloseCallBuffer,
  CloseProveBuffer,
  Initialize,
  InitializeCallBuffer,
  InitializeProveBuffer,
  ProveMessage,
  ProveMessageBuffered,
  RegisterOutputRoot,
  RelayMessage,
  SetAdjustmentDenominator,
  SetBlockIntervalRequirement,
  SetGasCostScaler,
  SetGasCostScalerDp,
  SetGasFeeReceiver,
  SetGasPerCall,
  SetGasTarget,
  SetMaxCallBufferSize,
  SetMinimumBaseFee,
  SetOracleSigners,
  SetPartnerOracleConfig,
  SetPauseStatus,
  SetWindowDuration,
  TransferGuardian,
  WrapToken,
}

export function identifyBridgeInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): BridgeInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([113, 115, 232, 194, 248, 32, 39, 21])
      ),
      0
    )
  ) {
    return BridgeInstruction.AppendToCallBuffer;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([4, 153, 157, 132, 144, 253, 235, 44])
      ),
      0
    )
  ) {
    return BridgeInstruction.AppendToProveBufferData;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([234, 13, 59, 98, 112, 207, 250, 184])
      ),
      0
    )
  ) {
    return BridgeInstruction.AppendToProveBufferProof;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([90, 23, 83, 238, 200, 18, 111, 95])
      ),
      0
    )
  ) {
    return BridgeInstruction.BridgeCall;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([138, 112, 52, 204, 33, 68, 62, 85])
      ),
      0
    )
  ) {
    return BridgeInstruction.BridgeCallBuffered;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([190, 190, 32, 158, 75, 153, 32, 86])
      ),
      0
    )
  ) {
    return BridgeInstruction.BridgeSol;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([52, 106, 74, 190, 246, 31, 157, 12])
      ),
      0
    )
  ) {
    return BridgeInstruction.BridgeSolWithBufferedCall;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([87, 109, 172, 103, 8, 187, 223, 126])
      ),
      0
    )
  ) {
    return BridgeInstruction.BridgeSpl;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([86, 187, 229, 4, 110, 8, 116, 153])
      ),
      0
    )
  ) {
    return BridgeInstruction.BridgeSplWithBufferedCall;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([55, 201, 139, 188, 226, 16, 136, 143])
      ),
      0
    )
  ) {
    return BridgeInstruction.BridgeWrappedToken;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([117, 175, 150, 237, 216, 76, 56, 5])
      ),
      0
    )
  ) {
    return BridgeInstruction.BridgeWrappedTokenWithBufferedCall;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([132, 188, 7, 198, 64, 178, 62, 29])
      ),
      0
    )
  ) {
    return BridgeInstruction.CloseCallBuffer;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([79, 14, 144, 49, 3, 124, 210, 74])
      ),
      0
    )
  ) {
    return BridgeInstruction.CloseProveBuffer;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([175, 175, 109, 31, 13, 152, 155, 237])
      ),
      0
    )
  ) {
    return BridgeInstruction.Initialize;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([85, 68, 100, 234, 255, 226, 95, 72])
      ),
      0
    )
  ) {
    return BridgeInstruction.InitializeCallBuffer;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([20, 200, 91, 188, 138, 211, 253, 222])
      ),
      0
    )
  ) {
    return BridgeInstruction.InitializeProveBuffer;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([172, 66, 78, 136, 158, 187, 47, 115])
      ),
      0
    )
  ) {
    return BridgeInstruction.ProveMessage;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([211, 48, 193, 183, 2, 51, 102, 159])
      ),
      0
    )
  ) {
    return BridgeInstruction.ProveMessageBuffered;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([215, 66, 12, 154, 4, 123, 196, 66])
      ),
      0
    )
  ) {
    return BridgeInstruction.RegisterOutputRoot;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([187, 90, 182, 138, 51, 248, 175, 98])
      ),
      0
    )
  ) {
    return BridgeInstruction.RelayMessage;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([31, 91, 190, 63, 164, 7, 31, 150])
      ),
      0
    )
  ) {
    return BridgeInstruction.SetAdjustmentDenominator;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([76, 70, 237, 100, 33, 108, 19, 42])
      ),
      0
    )
  ) {
    return BridgeInstruction.SetBlockIntervalRequirement;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([148, 146, 101, 170, 5, 6, 222, 119])
      ),
      0
    )
  ) {
    return BridgeInstruction.SetGasCostScaler;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([198, 111, 160, 55, 172, 138, 99, 164])
      ),
      0
    )
  ) {
    return BridgeInstruction.SetGasCostScalerDp;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([58, 188, 230, 188, 47, 188, 79, 154])
      ),
      0
    )
  ) {
    return BridgeInstruction.SetGasFeeReceiver;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([164, 95, 213, 130, 26, 69, 82, 127])
      ),
      0
    )
  ) {
    return BridgeInstruction.SetGasPerCall;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([132, 25, 19, 13, 118, 63, 167, 102])
      ),
      0
    )
  ) {
    return BridgeInstruction.SetGasTarget;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([140, 178, 4, 238, 245, 66, 117, 189])
      ),
      0
    )
  ) {
    return BridgeInstruction.SetMaxCallBufferSize;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([56, 95, 58, 94, 221, 136, 138, 156])
      ),
      0
    )
  ) {
    return BridgeInstruction.SetMinimumBaseFee;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([38, 183, 212, 67, 28, 241, 25, 160])
      ),
      0
    )
  ) {
    return BridgeInstruction.SetOracleSigners;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([34, 48, 231, 135, 42, 113, 217, 157])
      ),
      0
    )
  ) {
    return BridgeInstruction.SetPartnerOracleConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([118, 25, 145, 217, 114, 209, 236, 145])
      ),
      0
    )
  ) {
    return BridgeInstruction.SetPauseStatus;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([229, 2, 41, 119, 55, 255, 252, 205])
      ),
      0
    )
  ) {
    return BridgeInstruction.SetWindowDuration;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([118, 250, 162, 85, 197, 130, 116, 123])
      ),
      0
    )
  ) {
    return BridgeInstruction.TransferGuardian;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([203, 83, 204, 83, 225, 109, 44, 6])
      ),
      0
    )
  ) {
    return BridgeInstruction.WrapToken;
  }
  throw new Error(
    'The provided instruction could not be identified as a bridge instruction.'
  );
}

export type ParsedBridgeInstruction<TProgram extends string = 'undefined'> =
  | ({
      instructionType: BridgeInstruction.AppendToCallBuffer;
    } & ParsedAppendToCallBufferInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.AppendToProveBufferData;
    } & ParsedAppendToProveBufferDataInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.AppendToProveBufferProof;
    } & ParsedAppendToProveBufferProofInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.BridgeCall;
    } & ParsedBridgeCallInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.BridgeCallBuffered;
    } & ParsedBridgeCallBufferedInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.BridgeSol;
    } & ParsedBridgeSolInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.BridgeSolWithBufferedCall;
    } & ParsedBridgeSolWithBufferedCallInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.BridgeSpl;
    } & ParsedBridgeSplInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.BridgeSplWithBufferedCall;
    } & ParsedBridgeSplWithBufferedCallInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.BridgeWrappedToken;
    } & ParsedBridgeWrappedTokenInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.BridgeWrappedTokenWithBufferedCall;
    } & ParsedBridgeWrappedTokenWithBufferedCallInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.CloseCallBuffer;
    } & ParsedCloseCallBufferInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.CloseProveBuffer;
    } & ParsedCloseProveBufferInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.Initialize;
    } & ParsedInitializeInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.InitializeCallBuffer;
    } & ParsedInitializeCallBufferInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.InitializeProveBuffer;
    } & ParsedInitializeProveBufferInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.ProveMessage;
    } & ParsedProveMessageInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.ProveMessageBuffered;
    } & ParsedProveMessageBufferedInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.RegisterOutputRoot;
    } & ParsedRegisterOutputRootInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.RelayMessage;
    } & ParsedRelayMessageInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.SetAdjustmentDenominator;
    } & ParsedSetAdjustmentDenominatorInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.SetBlockIntervalRequirement;
    } & ParsedSetBlockIntervalRequirementInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.SetGasCostScaler;
    } & ParsedSetGasCostScalerInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.SetGasCostScalerDp;
    } & ParsedSetGasCostScalerDpInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.SetGasFeeReceiver;
    } & ParsedSetGasFeeReceiverInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.SetGasPerCall;
    } & ParsedSetGasPerCallInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.SetGasTarget;
    } & ParsedSetGasTargetInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.SetMaxCallBufferSize;
    } & ParsedSetMaxCallBufferSizeInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.SetMinimumBaseFee;
    } & ParsedSetMinimumBaseFeeInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.SetOracleSigners;
    } & ParsedSetOracleSignersInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.SetPartnerOracleConfig;
    } & ParsedSetPartnerOracleConfigInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.SetPauseStatus;
    } & ParsedSetPauseStatusInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.SetWindowDuration;
    } & ParsedSetWindowDurationInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.TransferGuardian;
    } & ParsedTransferGuardianInstruction<TProgram>)
  | ({
      instructionType: BridgeInstruction.WrapToken;
    } & ParsedWrapTokenInstruction<TProgram>);
