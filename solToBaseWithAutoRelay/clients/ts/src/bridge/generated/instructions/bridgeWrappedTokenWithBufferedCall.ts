/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import { BRIDGE_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const BRIDGE_WRAPPED_TOKEN_WITH_BUFFERED_CALL_DISCRIMINATOR =
  new Uint8Array([117, 175, 150, 237, 216, 76, 56, 5]);

export function getBridgeWrappedTokenWithBufferedCallDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    BRIDGE_WRAPPED_TOKEN_WITH_BUFFERED_CALL_DISCRIMINATOR
  );
}

export type BridgeWrappedTokenWithBufferedCallInstruction<
  TProgram extends string = typeof BRIDGE_PROGRAM_ADDRESS,
  TAccountPayer extends string | AccountMeta<string> = string,
  TAccountFrom extends string | AccountMeta<string> = string,
  TAccountGasFeeReceiver extends string | AccountMeta<string> = string,
  TAccountMint extends string | AccountMeta<string> = string,
  TAccountFromTokenAccount extends string | AccountMeta<string> = string,
  TAccountBridge extends string | AccountMeta<string> = string,
  TAccountOwner extends string | AccountMeta<string> = string,
  TAccountCallBuffer extends string | AccountMeta<string> = string,
  TAccountOutgoingMessage extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends
    | string
    | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountFrom extends string
        ? ReadonlySignerAccount<TAccountFrom> & AccountSignerMeta<TAccountFrom>
        : TAccountFrom,
      TAccountGasFeeReceiver extends string
        ? WritableAccount<TAccountGasFeeReceiver>
        : TAccountGasFeeReceiver,
      TAccountMint extends string
        ? WritableAccount<TAccountMint>
        : TAccountMint,
      TAccountFromTokenAccount extends string
        ? WritableAccount<TAccountFromTokenAccount>
        : TAccountFromTokenAccount,
      TAccountBridge extends string
        ? WritableAccount<TAccountBridge>
        : TAccountBridge,
      TAccountOwner extends string
        ? WritableSignerAccount<TAccountOwner> &
            AccountSignerMeta<TAccountOwner>
        : TAccountOwner,
      TAccountCallBuffer extends string
        ? WritableAccount<TAccountCallBuffer>
        : TAccountCallBuffer,
      TAccountOutgoingMessage extends string
        ? WritableAccount<TAccountOutgoingMessage>
        : TAccountOutgoingMessage,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      ...TRemainingAccounts,
    ]
  >;

export type BridgeWrappedTokenWithBufferedCallInstructionData = {
  discriminator: ReadonlyUint8Array;
  outgoingMessageSalt: ReadonlyUint8Array;
  to: ReadonlyUint8Array;
  amount: bigint;
};

export type BridgeWrappedTokenWithBufferedCallInstructionDataArgs = {
  outgoingMessageSalt: ReadonlyUint8Array;
  to: ReadonlyUint8Array;
  amount: number | bigint;
};

export function getBridgeWrappedTokenWithBufferedCallInstructionDataEncoder(): FixedSizeEncoder<BridgeWrappedTokenWithBufferedCallInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['outgoingMessageSalt', fixEncoderSize(getBytesEncoder(), 32)],
      ['to', fixEncoderSize(getBytesEncoder(), 20)],
      ['amount', getU64Encoder()],
    ]),
    (value) => ({
      ...value,
      discriminator: BRIDGE_WRAPPED_TOKEN_WITH_BUFFERED_CALL_DISCRIMINATOR,
    })
  );
}

export function getBridgeWrappedTokenWithBufferedCallInstructionDataDecoder(): FixedSizeDecoder<BridgeWrappedTokenWithBufferedCallInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['outgoingMessageSalt', fixDecoderSize(getBytesDecoder(), 32)],
    ['to', fixDecoderSize(getBytesDecoder(), 20)],
    ['amount', getU64Decoder()],
  ]);
}

export function getBridgeWrappedTokenWithBufferedCallInstructionDataCodec(): FixedSizeCodec<
  BridgeWrappedTokenWithBufferedCallInstructionDataArgs,
  BridgeWrappedTokenWithBufferedCallInstructionData
> {
  return combineCodec(
    getBridgeWrappedTokenWithBufferedCallInstructionDataEncoder(),
    getBridgeWrappedTokenWithBufferedCallInstructionDataDecoder()
  );
}

export type BridgeWrappedTokenWithBufferedCallInput<
  TAccountPayer extends string = string,
  TAccountFrom extends string = string,
  TAccountGasFeeReceiver extends string = string,
  TAccountMint extends string = string,
  TAccountFromTokenAccount extends string = string,
  TAccountBridge extends string = string,
  TAccountOwner extends string = string,
  TAccountCallBuffer extends string = string,
  TAccountOutgoingMessage extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  /**
   * The account that pays for transaction fees, gas fees, and outgoing message account creation.
   * Must be mutable to deduct lamports for account rent and gas fees (sent to `gas_fee_receiver`).
   */
  payer: TransactionSigner<TAccountPayer>;
  /**
   * The token owner who is bridging their wrapped tokens back to Base.
   * Must sign the transaction to authorize burning their tokens.
   */
  from: TransactionSigner<TAccountFrom>;
  /**
   * The account that receives payment for the gas costs of bridging the wrapped token to Base.
   * Mutable because lamports are transferred to this account.
   */
  gasFeeReceiver: Address<TAccountGasFeeReceiver>;
  /**
   * The wrapped token mint account representing the original Base token.
   * - Contains metadata linking to the original token on Base
   * - Supply will be reduced by burning tokens from the user's token account for this mint
   */
  mint: Address<TAccountMint>;
  /**
   * The user's token account holding the wrapped tokens to be bridged.
   * - Must contain sufficient token balance for the bridge amount
   * - Tokens will be burned from this account
   * - The burn authority must be the `from` signer (or a valid delegate)
   */
  fromTokenAccount: Address<TAccountFromTokenAccount>;
  /**
   * The main bridge state account storing global bridge configuration.
   * - Uses PDA with `BRIDGE_SEED` for deterministic address
   * - Tracks `nonce` for message ordering and maintains EIP-1559 fee state
   */
  bridge: Address<TAccountBridge>;
  /** The owner of the call buffer who will receive the rent refund. */
  owner: TransactionSigner<TAccountOwner>;
  /**
   * The call buffer account that stores the call data.
   * This account will be closed and rent returned to the owner.
   */
  callBuffer: Address<TAccountCallBuffer>;
  /**
   * The outgoing message account that stores the cross-chain transfer details.
   * Space is sized based on the current call buffer length so the call data fits.
   */
  outgoingMessage: Address<TAccountOutgoingMessage>;
  /** Token2022 program used for burning the wrapped tokens (burn_checked). */
  tokenProgram?: Address<TAccountTokenProgram>;
  /** System program required for creating the outgoing message account and transferring gas fees. */
  systemProgram?: Address<TAccountSystemProgram>;
  outgoingMessageSalt: BridgeWrappedTokenWithBufferedCallInstructionDataArgs['outgoingMessageSalt'];
  to: BridgeWrappedTokenWithBufferedCallInstructionDataArgs['to'];
  amount: BridgeWrappedTokenWithBufferedCallInstructionDataArgs['amount'];
};

export function getBridgeWrappedTokenWithBufferedCallInstruction<
  TAccountPayer extends string,
  TAccountFrom extends string,
  TAccountGasFeeReceiver extends string,
  TAccountMint extends string,
  TAccountFromTokenAccount extends string,
  TAccountBridge extends string,
  TAccountOwner extends string,
  TAccountCallBuffer extends string,
  TAccountOutgoingMessage extends string,
  TAccountTokenProgram extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof BRIDGE_PROGRAM_ADDRESS,
>(
  input: BridgeWrappedTokenWithBufferedCallInput<
    TAccountPayer,
    TAccountFrom,
    TAccountGasFeeReceiver,
    TAccountMint,
    TAccountFromTokenAccount,
    TAccountBridge,
    TAccountOwner,
    TAccountCallBuffer,
    TAccountOutgoingMessage,
    TAccountTokenProgram,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress }
): BridgeWrappedTokenWithBufferedCallInstruction<
  TProgramAddress,
  TAccountPayer,
  TAccountFrom,
  TAccountGasFeeReceiver,
  TAccountMint,
  TAccountFromTokenAccount,
  TAccountBridge,
  TAccountOwner,
  TAccountCallBuffer,
  TAccountOutgoingMessage,
  TAccountTokenProgram,
  TAccountSystemProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? BRIDGE_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    from: { value: input.from ?? null, isWritable: false },
    gasFeeReceiver: { value: input.gasFeeReceiver ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: true },
    fromTokenAccount: {
      value: input.fromTokenAccount ?? null,
      isWritable: true,
    },
    bridge: { value: input.bridge ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: true },
    callBuffer: { value: input.callBuffer ?? null, isWritable: true },
    outgoingMessage: { value: input.outgoingMessage ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.from),
      getAccountMeta(accounts.gasFeeReceiver),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.fromTokenAccount),
      getAccountMeta(accounts.bridge),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.callBuffer),
      getAccountMeta(accounts.outgoingMessage),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
    ],
    programAddress,
    data: getBridgeWrappedTokenWithBufferedCallInstructionDataEncoder().encode(
      args as BridgeWrappedTokenWithBufferedCallInstructionDataArgs
    ),
  } as BridgeWrappedTokenWithBufferedCallInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountFrom,
    TAccountGasFeeReceiver,
    TAccountMint,
    TAccountFromTokenAccount,
    TAccountBridge,
    TAccountOwner,
    TAccountCallBuffer,
    TAccountOutgoingMessage,
    TAccountTokenProgram,
    TAccountSystemProgram
  >;

  return instruction;
}

export type ParsedBridgeWrappedTokenWithBufferedCallInstruction<
  TProgram extends string = typeof BRIDGE_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /**
     * The account that pays for transaction fees, gas fees, and outgoing message account creation.
     * Must be mutable to deduct lamports for account rent and gas fees (sent to `gas_fee_receiver`).
     */

    payer: TAccountMetas[0];
    /**
     * The token owner who is bridging their wrapped tokens back to Base.
     * Must sign the transaction to authorize burning their tokens.
     */

    from: TAccountMetas[1];
    /**
     * The account that receives payment for the gas costs of bridging the wrapped token to Base.
     * Mutable because lamports are transferred to this account.
     */

    gasFeeReceiver: TAccountMetas[2];
    /**
     * The wrapped token mint account representing the original Base token.
     * - Contains metadata linking to the original token on Base
     * - Supply will be reduced by burning tokens from the user's token account for this mint
     */

    mint: TAccountMetas[3];
    /**
     * The user's token account holding the wrapped tokens to be bridged.
     * - Must contain sufficient token balance for the bridge amount
     * - Tokens will be burned from this account
     * - The burn authority must be the `from` signer (or a valid delegate)
     */

    fromTokenAccount: TAccountMetas[4];
    /**
     * The main bridge state account storing global bridge configuration.
     * - Uses PDA with `BRIDGE_SEED` for deterministic address
     * - Tracks `nonce` for message ordering and maintains EIP-1559 fee state
     */

    bridge: TAccountMetas[5];
    /** The owner of the call buffer who will receive the rent refund. */
    owner: TAccountMetas[6];
    /**
     * The call buffer account that stores the call data.
     * This account will be closed and rent returned to the owner.
     */

    callBuffer: TAccountMetas[7];
    /**
     * The outgoing message account that stores the cross-chain transfer details.
     * Space is sized based on the current call buffer length so the call data fits.
     */

    outgoingMessage: TAccountMetas[8];
    /** Token2022 program used for burning the wrapped tokens (burn_checked). */
    tokenProgram: TAccountMetas[9];
    /** System program required for creating the outgoing message account and transferring gas fees. */
    systemProgram: TAccountMetas[10];
  };
  data: BridgeWrappedTokenWithBufferedCallInstructionData;
};

export function parseBridgeWrappedTokenWithBufferedCallInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedBridgeWrappedTokenWithBufferedCallInstruction<
  TProgram,
  TAccountMetas
> {
  if (instruction.accounts.length < 11) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      from: getNextAccount(),
      gasFeeReceiver: getNextAccount(),
      mint: getNextAccount(),
      fromTokenAccount: getNextAccount(),
      bridge: getNextAccount(),
      owner: getNextAccount(),
      callBuffer: getNextAccount(),
      outgoingMessage: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
    },
    data: getBridgeWrappedTokenWithBufferedCallInstructionDataDecoder().decode(
      instruction.data
    ),
  };
}
