/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type Option,
  type OptionOrNullable,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import { BRIDGE_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';
import {
  getCallDecoder,
  getCallEncoder,
  type Call,
  type CallArgs,
} from '../types';

export const BRIDGE_SOL_DISCRIMINATOR = new Uint8Array([
  190, 190, 32, 158, 75, 153, 32, 86,
]);

export function getBridgeSolDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(BRIDGE_SOL_DISCRIMINATOR);
}

export type BridgeSolInstruction<
  TProgram extends string = typeof BRIDGE_PROGRAM_ADDRESS,
  TAccountPayer extends string | AccountMeta<string> = string,
  TAccountFrom extends string | AccountMeta<string> = string,
  TAccountGasFeeReceiver extends string | AccountMeta<string> = string,
  TAccountSolVault extends string | AccountMeta<string> = string,
  TAccountBridge extends string | AccountMeta<string> = string,
  TAccountOutgoingMessage extends string | AccountMeta<string> = string,
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountFrom extends string
        ? WritableSignerAccount<TAccountFrom> & AccountSignerMeta<TAccountFrom>
        : TAccountFrom,
      TAccountGasFeeReceiver extends string
        ? WritableAccount<TAccountGasFeeReceiver>
        : TAccountGasFeeReceiver,
      TAccountSolVault extends string
        ? WritableAccount<TAccountSolVault>
        : TAccountSolVault,
      TAccountBridge extends string
        ? WritableAccount<TAccountBridge>
        : TAccountBridge,
      TAccountOutgoingMessage extends string
        ? WritableAccount<TAccountOutgoingMessage>
        : TAccountOutgoingMessage,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      ...TRemainingAccounts,
    ]
  >;

export type BridgeSolInstructionData = {
  discriminator: ReadonlyUint8Array;
  outgoingMessageSalt: ReadonlyUint8Array;
  to: ReadonlyUint8Array;
  remoteToken: ReadonlyUint8Array;
  amount: bigint;
  call: Option<Call>;
};

export type BridgeSolInstructionDataArgs = {
  outgoingMessageSalt: ReadonlyUint8Array;
  to: ReadonlyUint8Array;
  remoteToken: ReadonlyUint8Array;
  amount: number | bigint;
  call: OptionOrNullable<CallArgs>;
};

export function getBridgeSolInstructionDataEncoder(): Encoder<BridgeSolInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['outgoingMessageSalt', fixEncoderSize(getBytesEncoder(), 32)],
      ['to', fixEncoderSize(getBytesEncoder(), 20)],
      ['remoteToken', fixEncoderSize(getBytesEncoder(), 20)],
      ['amount', getU64Encoder()],
      ['call', getOptionEncoder(getCallEncoder())],
    ]),
    (value) => ({ ...value, discriminator: BRIDGE_SOL_DISCRIMINATOR })
  );
}

export function getBridgeSolInstructionDataDecoder(): Decoder<BridgeSolInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['outgoingMessageSalt', fixDecoderSize(getBytesDecoder(), 32)],
    ['to', fixDecoderSize(getBytesDecoder(), 20)],
    ['remoteToken', fixDecoderSize(getBytesDecoder(), 20)],
    ['amount', getU64Decoder()],
    ['call', getOptionDecoder(getCallDecoder())],
  ]);
}

export function getBridgeSolInstructionDataCodec(): Codec<
  BridgeSolInstructionDataArgs,
  BridgeSolInstructionData
> {
  return combineCodec(
    getBridgeSolInstructionDataEncoder(),
    getBridgeSolInstructionDataDecoder()
  );
}

export type BridgeSolInput<
  TAccountPayer extends string = string,
  TAccountFrom extends string = string,
  TAccountGasFeeReceiver extends string = string,
  TAccountSolVault extends string = string,
  TAccountBridge extends string = string,
  TAccountOutgoingMessage extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  /**
   * The account that pays for transaction fees and account creation.
   * Must be mutable to deduct lamports for account rent and gas fees.
   */
  payer: TransactionSigner<TAccountPayer>;
  /**
   * The account that owns the SOL tokens being bridged.
   * Must sign the transaction to authorize the transfer of their SOL.
   */
  from: TransactionSigner<TAccountFrom>;
  /** The account that receives payment for the gas costs of bridging SOL to Base. */
  gasFeeReceiver: Address<TAccountGasFeeReceiver>;
  /**
   * The SOL vault account that holds locked tokens for the specific remote token.
   * - Uses PDA with SOL_VAULT_SEED and remote_token for deterministic address
   * - Mutable to receive the locked SOL tokens
   * - Each remote token has its own dedicated vault
   *
   */
  solVault: Address<TAccountSolVault>;
  /**
   * The main bridge state account that tracks nonces and fee parameters.
   * - Uses PDA with BRIDGE_SEED for deterministic address
   * - Mutable to increment nonce and update EIP1559 fee data
   */
  bridge: Address<TAccountBridge>;
  /**
   * The outgoing message account that stores cross-chain transfer details.
   * - Created fresh for each bridge operation
   * - Payer funds the account creation
   * - Space allocated dynamically based on optional call data size
   */
  outgoingMessage: Address<TAccountOutgoingMessage>;
  /**
   * System program required for SOL transfers and account creation.
   * Used for transferring SOL from user to vault and creating outgoing message accounts.
   */
  systemProgram?: Address<TAccountSystemProgram>;
  outgoingMessageSalt: BridgeSolInstructionDataArgs['outgoingMessageSalt'];
  to: BridgeSolInstructionDataArgs['to'];
  remoteToken: BridgeSolInstructionDataArgs['remoteToken'];
  amount: BridgeSolInstructionDataArgs['amount'];
  call: BridgeSolInstructionDataArgs['call'];
};

export function getBridgeSolInstruction<
  TAccountPayer extends string,
  TAccountFrom extends string,
  TAccountGasFeeReceiver extends string,
  TAccountSolVault extends string,
  TAccountBridge extends string,
  TAccountOutgoingMessage extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof BRIDGE_PROGRAM_ADDRESS,
>(
  input: BridgeSolInput<
    TAccountPayer,
    TAccountFrom,
    TAccountGasFeeReceiver,
    TAccountSolVault,
    TAccountBridge,
    TAccountOutgoingMessage,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress }
): BridgeSolInstruction<
  TProgramAddress,
  TAccountPayer,
  TAccountFrom,
  TAccountGasFeeReceiver,
  TAccountSolVault,
  TAccountBridge,
  TAccountOutgoingMessage,
  TAccountSystemProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? BRIDGE_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    from: { value: input.from ?? null, isWritable: true },
    gasFeeReceiver: { value: input.gasFeeReceiver ?? null, isWritable: true },
    solVault: { value: input.solVault ?? null, isWritable: true },
    bridge: { value: input.bridge ?? null, isWritable: true },
    outgoingMessage: { value: input.outgoingMessage ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.from),
      getAccountMeta(accounts.gasFeeReceiver),
      getAccountMeta(accounts.solVault),
      getAccountMeta(accounts.bridge),
      getAccountMeta(accounts.outgoingMessage),
      getAccountMeta(accounts.systemProgram),
    ],
    programAddress,
    data: getBridgeSolInstructionDataEncoder().encode(
      args as BridgeSolInstructionDataArgs
    ),
  } as BridgeSolInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountFrom,
    TAccountGasFeeReceiver,
    TAccountSolVault,
    TAccountBridge,
    TAccountOutgoingMessage,
    TAccountSystemProgram
  >;

  return instruction;
}

export type ParsedBridgeSolInstruction<
  TProgram extends string = typeof BRIDGE_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /**
     * The account that pays for transaction fees and account creation.
     * Must be mutable to deduct lamports for account rent and gas fees.
     */

    payer: TAccountMetas[0];
    /**
     * The account that owns the SOL tokens being bridged.
     * Must sign the transaction to authorize the transfer of their SOL.
     */

    from: TAccountMetas[1];
    /** The account that receives payment for the gas costs of bridging SOL to Base. */
    gasFeeReceiver: TAccountMetas[2];
    /**
     * The SOL vault account that holds locked tokens for the specific remote token.
     * - Uses PDA with SOL_VAULT_SEED and remote_token for deterministic address
     * - Mutable to receive the locked SOL tokens
     * - Each remote token has its own dedicated vault
     *
     */

    solVault: TAccountMetas[3];
    /**
     * The main bridge state account that tracks nonces and fee parameters.
     * - Uses PDA with BRIDGE_SEED for deterministic address
     * - Mutable to increment nonce and update EIP1559 fee data
     */

    bridge: TAccountMetas[4];
    /**
     * The outgoing message account that stores cross-chain transfer details.
     * - Created fresh for each bridge operation
     * - Payer funds the account creation
     * - Space allocated dynamically based on optional call data size
     */

    outgoingMessage: TAccountMetas[5];
    /**
     * System program required for SOL transfers and account creation.
     * Used for transferring SOL from user to vault and creating outgoing message accounts.
     */

    systemProgram: TAccountMetas[6];
  };
  data: BridgeSolInstructionData;
};

export function parseBridgeSolInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedBridgeSolInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 7) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      from: getNextAccount(),
      gasFeeReceiver: getNextAccount(),
      solVault: getNextAccount(),
      bridge: getNextAccount(),
      outgoingMessage: getNextAccount(),
      systemProgram: getNextAccount(),
    },
    data: getBridgeSolInstructionDataDecoder().decode(instruction.data),
  };
}
