/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU128Decoder,
  getU128Encoder,
  getU32Decoder,
  getU32Encoder,
  transformEncoder,
  type Account,
  type Address,
  type Codec,
  type Decoder,
  type EncodedAccount,
  type Encoder,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  getCallTypeDecoder,
  getCallTypeEncoder,
  type CallType,
  type CallTypeArgs,
} from '../types';

export const CALL_BUFFER_DISCRIMINATOR = new Uint8Array([
  134, 143, 168, 251, 163, 216, 180, 113,
]);

export function getCallBufferDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(CALL_BUFFER_DISCRIMINATOR);
}

export type CallBuffer = {
  discriminator: ReadonlyUint8Array;
  /** The owner who can modify this call buffer */
  owner: Address;
  /**
   * The type of call operation to perform (Call, DelegateCall, Create, or Create2).
   * Determines how the call will be executed on the Base side.
   */
  ty: CallType;
  /**
   * The target address on Base (20 bytes for Ethereum-compatible address).
   * Must be set to zero for Create and Create2 operations.
   */
  to: ReadonlyUint8Array;
  /** The amount of Base native currency (ETH) to send with this call, in wei. */
  value: bigint;
  /**
   * The encoded function call data or contract bytecode.
   * For regular calls: ABI-encoded function signature and parameters.
   * For contract creation: the contract's initialization bytecode.
   */
  data: ReadonlyUint8Array;
};

export type CallBufferArgs = {
  /** The owner who can modify this call buffer */
  owner: Address;
  /**
   * The type of call operation to perform (Call, DelegateCall, Create, or Create2).
   * Determines how the call will be executed on the Base side.
   */
  ty: CallTypeArgs;
  /**
   * The target address on Base (20 bytes for Ethereum-compatible address).
   * Must be set to zero for Create and Create2 operations.
   */
  to: ReadonlyUint8Array;
  /** The amount of Base native currency (ETH) to send with this call, in wei. */
  value: number | bigint;
  /**
   * The encoded function call data or contract bytecode.
   * For regular calls: ABI-encoded function signature and parameters.
   * For contract creation: the contract's initialization bytecode.
   */
  data: ReadonlyUint8Array;
};

export function getCallBufferEncoder(): Encoder<CallBufferArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['owner', getAddressEncoder()],
      ['ty', getCallTypeEncoder()],
      ['to', fixEncoderSize(getBytesEncoder(), 20)],
      ['value', getU128Encoder()],
      ['data', addEncoderSizePrefix(getBytesEncoder(), getU32Encoder())],
    ]),
    (value) => ({ ...value, discriminator: CALL_BUFFER_DISCRIMINATOR })
  );
}

export function getCallBufferDecoder(): Decoder<CallBuffer> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['owner', getAddressDecoder()],
    ['ty', getCallTypeDecoder()],
    ['to', fixDecoderSize(getBytesDecoder(), 20)],
    ['value', getU128Decoder()],
    ['data', addDecoderSizePrefix(getBytesDecoder(), getU32Decoder())],
  ]);
}

export function getCallBufferCodec(): Codec<CallBufferArgs, CallBuffer> {
  return combineCodec(getCallBufferEncoder(), getCallBufferDecoder());
}

export function decodeCallBuffer<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<CallBuffer, TAddress>;
export function decodeCallBuffer<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<CallBuffer, TAddress>;
export function decodeCallBuffer<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<CallBuffer, TAddress> | MaybeAccount<CallBuffer, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getCallBufferDecoder()
  );
}

export async function fetchCallBuffer<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<CallBuffer, TAddress>> {
  const maybeAccount = await fetchMaybeCallBuffer(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeCallBuffer<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<CallBuffer, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeCallBuffer(maybeAccount);
}

export async function fetchAllCallBuffer(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<CallBuffer>[]> {
  const maybeAccounts = await fetchAllMaybeCallBuffer(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeCallBuffer(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<CallBuffer>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeCallBuffer(maybeAccount));
}
