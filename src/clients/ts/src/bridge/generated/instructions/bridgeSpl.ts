/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type Option,
  type OptionOrNullable,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import { BRIDGE_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';
import {
  getCallDecoder,
  getCallEncoder,
  type Call,
  type CallArgs,
} from '../types';

export const BRIDGE_SPL_DISCRIMINATOR = new Uint8Array([
  87, 109, 172, 103, 8, 187, 223, 126,
]);

export function getBridgeSplDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(BRIDGE_SPL_DISCRIMINATOR);
}

export type BridgeSplInstruction<
  TProgram extends string = typeof BRIDGE_PROGRAM_ADDRESS,
  TAccountPayer extends string | AccountMeta<string> = string,
  TAccountFrom extends string | AccountMeta<string> = string,
  TAccountGasFeeReceiver extends string | AccountMeta<string> = string,
  TAccountMint extends string | AccountMeta<string> = string,
  TAccountFromTokenAccount extends string | AccountMeta<string> = string,
  TAccountBridge extends string | AccountMeta<string> = string,
  TAccountTokenVault extends string | AccountMeta<string> = string,
  TAccountOutgoingMessage extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends
    | string
    | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountFrom extends string
        ? WritableSignerAccount<TAccountFrom> & AccountSignerMeta<TAccountFrom>
        : TAccountFrom,
      TAccountGasFeeReceiver extends string
        ? WritableAccount<TAccountGasFeeReceiver>
        : TAccountGasFeeReceiver,
      TAccountMint extends string
        ? WritableAccount<TAccountMint>
        : TAccountMint,
      TAccountFromTokenAccount extends string
        ? WritableAccount<TAccountFromTokenAccount>
        : TAccountFromTokenAccount,
      TAccountBridge extends string
        ? WritableAccount<TAccountBridge>
        : TAccountBridge,
      TAccountTokenVault extends string
        ? WritableAccount<TAccountTokenVault>
        : TAccountTokenVault,
      TAccountOutgoingMessage extends string
        ? WritableAccount<TAccountOutgoingMessage>
        : TAccountOutgoingMessage,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      ...TRemainingAccounts,
    ]
  >;

export type BridgeSplInstructionData = {
  discriminator: ReadonlyUint8Array;
  outgoingMessageSalt: ReadonlyUint8Array;
  to: ReadonlyUint8Array;
  remoteToken: ReadonlyUint8Array;
  amount: bigint;
  call: Option<Call>;
};

export type BridgeSplInstructionDataArgs = {
  outgoingMessageSalt: ReadonlyUint8Array;
  to: ReadonlyUint8Array;
  remoteToken: ReadonlyUint8Array;
  amount: number | bigint;
  call: OptionOrNullable<CallArgs>;
};

export function getBridgeSplInstructionDataEncoder(): Encoder<BridgeSplInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['outgoingMessageSalt', fixEncoderSize(getBytesEncoder(), 32)],
      ['to', fixEncoderSize(getBytesEncoder(), 20)],
      ['remoteToken', fixEncoderSize(getBytesEncoder(), 20)],
      ['amount', getU64Encoder()],
      ['call', getOptionEncoder(getCallEncoder())],
    ]),
    (value) => ({ ...value, discriminator: BRIDGE_SPL_DISCRIMINATOR })
  );
}

export function getBridgeSplInstructionDataDecoder(): Decoder<BridgeSplInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['outgoingMessageSalt', fixDecoderSize(getBytesDecoder(), 32)],
    ['to', fixDecoderSize(getBytesDecoder(), 20)],
    ['remoteToken', fixDecoderSize(getBytesDecoder(), 20)],
    ['amount', getU64Decoder()],
    ['call', getOptionDecoder(getCallDecoder())],
  ]);
}

export function getBridgeSplInstructionDataCodec(): Codec<
  BridgeSplInstructionDataArgs,
  BridgeSplInstructionData
> {
  return combineCodec(
    getBridgeSplInstructionDataEncoder(),
    getBridgeSplInstructionDataDecoder()
  );
}

export type BridgeSplInput<
  TAccountPayer extends string = string,
  TAccountFrom extends string = string,
  TAccountGasFeeReceiver extends string = string,
  TAccountMint extends string = string,
  TAccountFromTokenAccount extends string = string,
  TAccountBridge extends string = string,
  TAccountTokenVault extends string = string,
  TAccountOutgoingMessage extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  /**
   * The account that pays for transaction fees and account creation.
   * Must be mutable to deduct lamports for gas fees and new account rent.
   */
  payer: TransactionSigner<TAccountPayer>;
  /**
   * The token authority authorizing the transfer of SPL tokens.
   * This signer must be the owner or an approved delegate for the source token account.
   */
  from: TransactionSigner<TAccountFrom>;
  /** The account that receives payment for the gas costs of bridging the SPL token to Base. */
  gasFeeReceiver: Address<TAccountGasFeeReceiver>;
  /**
   * The SPL token mint account for the token being bridged.
   * - Must not be a wrapped token (wrapped tokens use bridge_wrapped_token)
   * - Used to read token decimals and validate it is not a wrapped token
   */
  mint: Address<TAccountMint>;
  /**
   * The user's token account containing the SPL tokens to be bridged.
   * - Must be owned by, or delegated to, the `from` signer (transfer authority)
   * - Tokens will be transferred from this account to the token vault
   */
  fromTokenAccount: Address<TAccountFromTokenAccount>;
  /**
   * The main bridge state account containing global bridge configuration.
   * - PDA with BRIDGE_SEED for deterministic address
   * - Tracks nonce for message ordering and EIP-1559 gas pricing
   * - Nonce is incremented after successful bridge operations
   */
  bridge: Address<TAccountBridge>;
  /**
   * The token vault account that holds locked SPL tokens during the bridge process.
   * - PDA derived from TOKEN_VAULT_SEED, mint pubkey, and remote_token address
   * - Created if it doesn't exist for this mint/remote_token pair
   * - Token account authority is set to this vault PDA; the program signs using the PDA seeds
   * - Acts as the custody account for tokens being bridged to Base
   */
  tokenVault: Address<TAccountTokenVault>;
  /**
   * The outgoing message account that represents this bridge operation.
   * - Contains transfer details and optional call data for the destination chain
   * - Space is calculated based on the size of optional call data
   * - Used by relayers to execute the bridge operation on Base
   * - The recorded transfer amount equals the net increase in `token_vault` balance
   */
  outgoingMessage: Address<TAccountOutgoingMessage>;
  /**
   * The SPL Token program interface for executing token transfers.
   * Used for the transfer_checked operation to move tokens to the vault.
   */
  tokenProgram?: Address<TAccountTokenProgram>;
  /**
   * System program required for creating the outgoing message account and
   * initializing the token vault when needed.
   */
  systemProgram?: Address<TAccountSystemProgram>;
  outgoingMessageSalt: BridgeSplInstructionDataArgs['outgoingMessageSalt'];
  to: BridgeSplInstructionDataArgs['to'];
  remoteToken: BridgeSplInstructionDataArgs['remoteToken'];
  amount: BridgeSplInstructionDataArgs['amount'];
  call: BridgeSplInstructionDataArgs['call'];
};

export function getBridgeSplInstruction<
  TAccountPayer extends string,
  TAccountFrom extends string,
  TAccountGasFeeReceiver extends string,
  TAccountMint extends string,
  TAccountFromTokenAccount extends string,
  TAccountBridge extends string,
  TAccountTokenVault extends string,
  TAccountOutgoingMessage extends string,
  TAccountTokenProgram extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof BRIDGE_PROGRAM_ADDRESS,
>(
  input: BridgeSplInput<
    TAccountPayer,
    TAccountFrom,
    TAccountGasFeeReceiver,
    TAccountMint,
    TAccountFromTokenAccount,
    TAccountBridge,
    TAccountTokenVault,
    TAccountOutgoingMessage,
    TAccountTokenProgram,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress }
): BridgeSplInstruction<
  TProgramAddress,
  TAccountPayer,
  TAccountFrom,
  TAccountGasFeeReceiver,
  TAccountMint,
  TAccountFromTokenAccount,
  TAccountBridge,
  TAccountTokenVault,
  TAccountOutgoingMessage,
  TAccountTokenProgram,
  TAccountSystemProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? BRIDGE_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    from: { value: input.from ?? null, isWritable: true },
    gasFeeReceiver: { value: input.gasFeeReceiver ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: true },
    fromTokenAccount: {
      value: input.fromTokenAccount ?? null,
      isWritable: true,
    },
    bridge: { value: input.bridge ?? null, isWritable: true },
    tokenVault: { value: input.tokenVault ?? null, isWritable: true },
    outgoingMessage: { value: input.outgoingMessage ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.from),
      getAccountMeta(accounts.gasFeeReceiver),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.fromTokenAccount),
      getAccountMeta(accounts.bridge),
      getAccountMeta(accounts.tokenVault),
      getAccountMeta(accounts.outgoingMessage),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
    ],
    programAddress,
    data: getBridgeSplInstructionDataEncoder().encode(
      args as BridgeSplInstructionDataArgs
    ),
  } as BridgeSplInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountFrom,
    TAccountGasFeeReceiver,
    TAccountMint,
    TAccountFromTokenAccount,
    TAccountBridge,
    TAccountTokenVault,
    TAccountOutgoingMessage,
    TAccountTokenProgram,
    TAccountSystemProgram
  >;

  return instruction;
}

export type ParsedBridgeSplInstruction<
  TProgram extends string = typeof BRIDGE_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /**
     * The account that pays for transaction fees and account creation.
     * Must be mutable to deduct lamports for gas fees and new account rent.
     */

    payer: TAccountMetas[0];
    /**
     * The token authority authorizing the transfer of SPL tokens.
     * This signer must be the owner or an approved delegate for the source token account.
     */

    from: TAccountMetas[1];
    /** The account that receives payment for the gas costs of bridging the SPL token to Base. */
    gasFeeReceiver: TAccountMetas[2];
    /**
     * The SPL token mint account for the token being bridged.
     * - Must not be a wrapped token (wrapped tokens use bridge_wrapped_token)
     * - Used to read token decimals and validate it is not a wrapped token
     */

    mint: TAccountMetas[3];
    /**
     * The user's token account containing the SPL tokens to be bridged.
     * - Must be owned by, or delegated to, the `from` signer (transfer authority)
     * - Tokens will be transferred from this account to the token vault
     */

    fromTokenAccount: TAccountMetas[4];
    /**
     * The main bridge state account containing global bridge configuration.
     * - PDA with BRIDGE_SEED for deterministic address
     * - Tracks nonce for message ordering and EIP-1559 gas pricing
     * - Nonce is incremented after successful bridge operations
     */

    bridge: TAccountMetas[5];
    /**
     * The token vault account that holds locked SPL tokens during the bridge process.
     * - PDA derived from TOKEN_VAULT_SEED, mint pubkey, and remote_token address
     * - Created if it doesn't exist for this mint/remote_token pair
     * - Token account authority is set to this vault PDA; the program signs using the PDA seeds
     * - Acts as the custody account for tokens being bridged to Base
     */

    tokenVault: TAccountMetas[6];
    /**
     * The outgoing message account that represents this bridge operation.
     * - Contains transfer details and optional call data for the destination chain
     * - Space is calculated based on the size of optional call data
     * - Used by relayers to execute the bridge operation on Base
     * - The recorded transfer amount equals the net increase in `token_vault` balance
     */

    outgoingMessage: TAccountMetas[7];
    /**
     * The SPL Token program interface for executing token transfers.
     * Used for the transfer_checked operation to move tokens to the vault.
     */

    tokenProgram: TAccountMetas[8];
    /**
     * System program required for creating the outgoing message account and
     * initializing the token vault when needed.
     */

    systemProgram: TAccountMetas[9];
  };
  data: BridgeSplInstructionData;
};

export function parseBridgeSplInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedBridgeSplInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 10) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      from: getNextAccount(),
      gasFeeReceiver: getNextAccount(),
      mint: getNextAccount(),
      fromTokenAccount: getNextAccount(),
      bridge: getNextAccount(),
      tokenVault: getNextAccount(),
      outgoingMessage: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
    },
    data: getBridgeSplInstructionDataDecoder().decode(instruction.data),
  };
}
