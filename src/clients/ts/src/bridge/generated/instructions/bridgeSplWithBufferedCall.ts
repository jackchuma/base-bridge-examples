/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import { BRIDGE_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const BRIDGE_SPL_WITH_BUFFERED_CALL_DISCRIMINATOR = new Uint8Array([
  86, 187, 229, 4, 110, 8, 116, 153,
]);

export function getBridgeSplWithBufferedCallDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    BRIDGE_SPL_WITH_BUFFERED_CALL_DISCRIMINATOR
  );
}

export type BridgeSplWithBufferedCallInstruction<
  TProgram extends string = typeof BRIDGE_PROGRAM_ADDRESS,
  TAccountPayer extends string | AccountMeta<string> = string,
  TAccountFrom extends string | AccountMeta<string> = string,
  TAccountGasFeeReceiver extends string | AccountMeta<string> = string,
  TAccountMint extends string | AccountMeta<string> = string,
  TAccountFromTokenAccount extends string | AccountMeta<string> = string,
  TAccountBridge extends string | AccountMeta<string> = string,
  TAccountTokenVault extends string | AccountMeta<string> = string,
  TAccountOwner extends string | AccountMeta<string> = string,
  TAccountCallBuffer extends string | AccountMeta<string> = string,
  TAccountOutgoingMessage extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends
    | string
    | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountFrom extends string
        ? WritableSignerAccount<TAccountFrom> & AccountSignerMeta<TAccountFrom>
        : TAccountFrom,
      TAccountGasFeeReceiver extends string
        ? WritableAccount<TAccountGasFeeReceiver>
        : TAccountGasFeeReceiver,
      TAccountMint extends string
        ? WritableAccount<TAccountMint>
        : TAccountMint,
      TAccountFromTokenAccount extends string
        ? WritableAccount<TAccountFromTokenAccount>
        : TAccountFromTokenAccount,
      TAccountBridge extends string
        ? WritableAccount<TAccountBridge>
        : TAccountBridge,
      TAccountTokenVault extends string
        ? WritableAccount<TAccountTokenVault>
        : TAccountTokenVault,
      TAccountOwner extends string
        ? WritableSignerAccount<TAccountOwner> &
            AccountSignerMeta<TAccountOwner>
        : TAccountOwner,
      TAccountCallBuffer extends string
        ? WritableAccount<TAccountCallBuffer>
        : TAccountCallBuffer,
      TAccountOutgoingMessage extends string
        ? WritableAccount<TAccountOutgoingMessage>
        : TAccountOutgoingMessage,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      ...TRemainingAccounts,
    ]
  >;

export type BridgeSplWithBufferedCallInstructionData = {
  discriminator: ReadonlyUint8Array;
  outgoingMessageSalt: ReadonlyUint8Array;
  to: ReadonlyUint8Array;
  remoteToken: ReadonlyUint8Array;
  amount: bigint;
};

export type BridgeSplWithBufferedCallInstructionDataArgs = {
  outgoingMessageSalt: ReadonlyUint8Array;
  to: ReadonlyUint8Array;
  remoteToken: ReadonlyUint8Array;
  amount: number | bigint;
};

export function getBridgeSplWithBufferedCallInstructionDataEncoder(): FixedSizeEncoder<BridgeSplWithBufferedCallInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['outgoingMessageSalt', fixEncoderSize(getBytesEncoder(), 32)],
      ['to', fixEncoderSize(getBytesEncoder(), 20)],
      ['remoteToken', fixEncoderSize(getBytesEncoder(), 20)],
      ['amount', getU64Encoder()],
    ]),
    (value) => ({
      ...value,
      discriminator: BRIDGE_SPL_WITH_BUFFERED_CALL_DISCRIMINATOR,
    })
  );
}

export function getBridgeSplWithBufferedCallInstructionDataDecoder(): FixedSizeDecoder<BridgeSplWithBufferedCallInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['outgoingMessageSalt', fixDecoderSize(getBytesDecoder(), 32)],
    ['to', fixDecoderSize(getBytesDecoder(), 20)],
    ['remoteToken', fixDecoderSize(getBytesDecoder(), 20)],
    ['amount', getU64Decoder()],
  ]);
}

export function getBridgeSplWithBufferedCallInstructionDataCodec(): FixedSizeCodec<
  BridgeSplWithBufferedCallInstructionDataArgs,
  BridgeSplWithBufferedCallInstructionData
> {
  return combineCodec(
    getBridgeSplWithBufferedCallInstructionDataEncoder(),
    getBridgeSplWithBufferedCallInstructionDataDecoder()
  );
}

export type BridgeSplWithBufferedCallInput<
  TAccountPayer extends string = string,
  TAccountFrom extends string = string,
  TAccountGasFeeReceiver extends string = string,
  TAccountMint extends string = string,
  TAccountFromTokenAccount extends string = string,
  TAccountBridge extends string = string,
  TAccountTokenVault extends string = string,
  TAccountOwner extends string = string,
  TAccountCallBuffer extends string = string,
  TAccountOutgoingMessage extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  /**
   * The account that pays for transaction fees and account creation.
   * Must be mutable to deduct lamports for gas fees and new account rent.
   */
  payer: TransactionSigner<TAccountPayer>;
  /**
   * The token authority authorizing the transfer of SPL tokens.
   * This signer must be the owner or an approved delegate for the source token account.
   */
  from: TransactionSigner<TAccountFrom>;
  /** The account that receives payment for the gas costs of bridging the SPL token to Base. */
  gasFeeReceiver: Address<TAccountGasFeeReceiver>;
  /**
   * The SPL token mint account for the token being bridged.
   * - Must not be a wrapped token (wrapped tokens use bridge_wrapped_token)
   * - Used to validate transfer amounts and get token metadata
   */
  mint: Address<TAccountMint>;
  /**
   * The user's token account containing the SPL tokens to be bridged.
   * - Must be owned by, or delegated to, the `from` signer (transfer authority)
   * - Tokens will be transferred from this account to the token vault
   */
  fromTokenAccount: Address<TAccountFromTokenAccount>;
  /**
   * The main bridge state account containing global bridge configuration.
   * - PDA with BRIDGE_SEED for deterministic address
   * - Tracks nonce for message ordering and EIP-1559 gas pricing
   * - Nonce is incremented after successful bridge operations
   */
  bridge: Address<TAccountBridge>;
  /**
   * The token vault account that holds locked SPL tokens during the bridge process.
   * - PDA derived from TOKEN_VAULT_SEED, mint pubkey, and remote_token address
   * - Created if it doesn't exist for this mint/remote_token pair
   * - Token account authority is set to this vault PDA; the program signs using the PDA seeds
   * - Acts as the custody account for tokens being bridged to Base
   */
  tokenVault: Address<TAccountTokenVault>;
  /** The owner of the call buffer who will receive the rent refund. */
  owner: TransactionSigner<TAccountOwner>;
  /**
   * The call buffer account that stores the call data.
   * This account will be closed and rent returned to the owner.
   */
  callBuffer: Address<TAccountCallBuffer>;
  /** The outgoing message account that stores the cross-chain transfer details. */
  outgoingMessage: Address<TAccountOutgoingMessage>;
  /**
   * The SPL Token program interface for executing token transfers.
   * Used for the transfer_checked operation to move tokens to the vault.
   */
  tokenProgram?: Address<TAccountTokenProgram>;
  /**
   * System program required for creating the outgoing message account and
   * initializing the token vault when needed.
   */
  systemProgram?: Address<TAccountSystemProgram>;
  outgoingMessageSalt: BridgeSplWithBufferedCallInstructionDataArgs['outgoingMessageSalt'];
  to: BridgeSplWithBufferedCallInstructionDataArgs['to'];
  remoteToken: BridgeSplWithBufferedCallInstructionDataArgs['remoteToken'];
  amount: BridgeSplWithBufferedCallInstructionDataArgs['amount'];
};

export function getBridgeSplWithBufferedCallInstruction<
  TAccountPayer extends string,
  TAccountFrom extends string,
  TAccountGasFeeReceiver extends string,
  TAccountMint extends string,
  TAccountFromTokenAccount extends string,
  TAccountBridge extends string,
  TAccountTokenVault extends string,
  TAccountOwner extends string,
  TAccountCallBuffer extends string,
  TAccountOutgoingMessage extends string,
  TAccountTokenProgram extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof BRIDGE_PROGRAM_ADDRESS,
>(
  input: BridgeSplWithBufferedCallInput<
    TAccountPayer,
    TAccountFrom,
    TAccountGasFeeReceiver,
    TAccountMint,
    TAccountFromTokenAccount,
    TAccountBridge,
    TAccountTokenVault,
    TAccountOwner,
    TAccountCallBuffer,
    TAccountOutgoingMessage,
    TAccountTokenProgram,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress }
): BridgeSplWithBufferedCallInstruction<
  TProgramAddress,
  TAccountPayer,
  TAccountFrom,
  TAccountGasFeeReceiver,
  TAccountMint,
  TAccountFromTokenAccount,
  TAccountBridge,
  TAccountTokenVault,
  TAccountOwner,
  TAccountCallBuffer,
  TAccountOutgoingMessage,
  TAccountTokenProgram,
  TAccountSystemProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? BRIDGE_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    from: { value: input.from ?? null, isWritable: true },
    gasFeeReceiver: { value: input.gasFeeReceiver ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: true },
    fromTokenAccount: {
      value: input.fromTokenAccount ?? null,
      isWritable: true,
    },
    bridge: { value: input.bridge ?? null, isWritable: true },
    tokenVault: { value: input.tokenVault ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: true },
    callBuffer: { value: input.callBuffer ?? null, isWritable: true },
    outgoingMessage: { value: input.outgoingMessage ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.from),
      getAccountMeta(accounts.gasFeeReceiver),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.fromTokenAccount),
      getAccountMeta(accounts.bridge),
      getAccountMeta(accounts.tokenVault),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.callBuffer),
      getAccountMeta(accounts.outgoingMessage),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
    ],
    programAddress,
    data: getBridgeSplWithBufferedCallInstructionDataEncoder().encode(
      args as BridgeSplWithBufferedCallInstructionDataArgs
    ),
  } as BridgeSplWithBufferedCallInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountFrom,
    TAccountGasFeeReceiver,
    TAccountMint,
    TAccountFromTokenAccount,
    TAccountBridge,
    TAccountTokenVault,
    TAccountOwner,
    TAccountCallBuffer,
    TAccountOutgoingMessage,
    TAccountTokenProgram,
    TAccountSystemProgram
  >;

  return instruction;
}

export type ParsedBridgeSplWithBufferedCallInstruction<
  TProgram extends string = typeof BRIDGE_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /**
     * The account that pays for transaction fees and account creation.
     * Must be mutable to deduct lamports for gas fees and new account rent.
     */

    payer: TAccountMetas[0];
    /**
     * The token authority authorizing the transfer of SPL tokens.
     * This signer must be the owner or an approved delegate for the source token account.
     */

    from: TAccountMetas[1];
    /** The account that receives payment for the gas costs of bridging the SPL token to Base. */
    gasFeeReceiver: TAccountMetas[2];
    /**
     * The SPL token mint account for the token being bridged.
     * - Must not be a wrapped token (wrapped tokens use bridge_wrapped_token)
     * - Used to validate transfer amounts and get token metadata
     */

    mint: TAccountMetas[3];
    /**
     * The user's token account containing the SPL tokens to be bridged.
     * - Must be owned by, or delegated to, the `from` signer (transfer authority)
     * - Tokens will be transferred from this account to the token vault
     */

    fromTokenAccount: TAccountMetas[4];
    /**
     * The main bridge state account containing global bridge configuration.
     * - PDA with BRIDGE_SEED for deterministic address
     * - Tracks nonce for message ordering and EIP-1559 gas pricing
     * - Nonce is incremented after successful bridge operations
     */

    bridge: TAccountMetas[5];
    /**
     * The token vault account that holds locked SPL tokens during the bridge process.
     * - PDA derived from TOKEN_VAULT_SEED, mint pubkey, and remote_token address
     * - Created if it doesn't exist for this mint/remote_token pair
     * - Token account authority is set to this vault PDA; the program signs using the PDA seeds
     * - Acts as the custody account for tokens being bridged to Base
     */

    tokenVault: TAccountMetas[6];
    /** The owner of the call buffer who will receive the rent refund. */
    owner: TAccountMetas[7];
    /**
     * The call buffer account that stores the call data.
     * This account will be closed and rent returned to the owner.
     */

    callBuffer: TAccountMetas[8];
    /** The outgoing message account that stores the cross-chain transfer details. */
    outgoingMessage: TAccountMetas[9];
    /**
     * The SPL Token program interface for executing token transfers.
     * Used for the transfer_checked operation to move tokens to the vault.
     */

    tokenProgram: TAccountMetas[10];
    /**
     * System program required for creating the outgoing message account and
     * initializing the token vault when needed.
     */

    systemProgram: TAccountMetas[11];
  };
  data: BridgeSplWithBufferedCallInstructionData;
};

export function parseBridgeSplWithBufferedCallInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedBridgeSplWithBufferedCallInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 12) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      from: getNextAccount(),
      gasFeeReceiver: getNextAccount(),
      mint: getNextAccount(),
      fromTokenAccount: getNextAccount(),
      bridge: getNextAccount(),
      tokenVault: getNextAccount(),
      owner: getNextAccount(),
      callBuffer: getNextAccount(),
      outgoingMessage: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
    },
    data: getBridgeSplWithBufferedCallInstructionDataDecoder().decode(
      instruction.data
    ),
  };
}
