/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type Option,
  type OptionOrNullable,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import { BRIDGE_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';
import {
  getCallDecoder,
  getCallEncoder,
  type Call,
  type CallArgs,
} from '../types';

export const BRIDGE_WRAPPED_TOKEN_DISCRIMINATOR = new Uint8Array([
  55, 201, 139, 188, 226, 16, 136, 143,
]);

export function getBridgeWrappedTokenDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    BRIDGE_WRAPPED_TOKEN_DISCRIMINATOR
  );
}

export type BridgeWrappedTokenInstruction<
  TProgram extends string = typeof BRIDGE_PROGRAM_ADDRESS,
  TAccountPayer extends string | AccountMeta<string> = string,
  TAccountFrom extends string | AccountMeta<string> = string,
  TAccountGasFeeReceiver extends string | AccountMeta<string> = string,
  TAccountMint extends string | AccountMeta<string> = string,
  TAccountFromTokenAccount extends string | AccountMeta<string> = string,
  TAccountBridge extends string | AccountMeta<string> = string,
  TAccountOutgoingMessage extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends
    | string
    | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountFrom extends string
        ? ReadonlySignerAccount<TAccountFrom> & AccountSignerMeta<TAccountFrom>
        : TAccountFrom,
      TAccountGasFeeReceiver extends string
        ? WritableAccount<TAccountGasFeeReceiver>
        : TAccountGasFeeReceiver,
      TAccountMint extends string
        ? WritableAccount<TAccountMint>
        : TAccountMint,
      TAccountFromTokenAccount extends string
        ? WritableAccount<TAccountFromTokenAccount>
        : TAccountFromTokenAccount,
      TAccountBridge extends string
        ? WritableAccount<TAccountBridge>
        : TAccountBridge,
      TAccountOutgoingMessage extends string
        ? WritableAccount<TAccountOutgoingMessage>
        : TAccountOutgoingMessage,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      ...TRemainingAccounts,
    ]
  >;

export type BridgeWrappedTokenInstructionData = {
  discriminator: ReadonlyUint8Array;
  outgoingMessageSalt: ReadonlyUint8Array;
  to: ReadonlyUint8Array;
  amount: bigint;
  call: Option<Call>;
};

export type BridgeWrappedTokenInstructionDataArgs = {
  outgoingMessageSalt: ReadonlyUint8Array;
  to: ReadonlyUint8Array;
  amount: number | bigint;
  call: OptionOrNullable<CallArgs>;
};

export function getBridgeWrappedTokenInstructionDataEncoder(): Encoder<BridgeWrappedTokenInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['outgoingMessageSalt', fixEncoderSize(getBytesEncoder(), 32)],
      ['to', fixEncoderSize(getBytesEncoder(), 20)],
      ['amount', getU64Encoder()],
      ['call', getOptionEncoder(getCallEncoder())],
    ]),
    (value) => ({ ...value, discriminator: BRIDGE_WRAPPED_TOKEN_DISCRIMINATOR })
  );
}

export function getBridgeWrappedTokenInstructionDataDecoder(): Decoder<BridgeWrappedTokenInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['outgoingMessageSalt', fixDecoderSize(getBytesDecoder(), 32)],
    ['to', fixDecoderSize(getBytesDecoder(), 20)],
    ['amount', getU64Decoder()],
    ['call', getOptionDecoder(getCallDecoder())],
  ]);
}

export function getBridgeWrappedTokenInstructionDataCodec(): Codec<
  BridgeWrappedTokenInstructionDataArgs,
  BridgeWrappedTokenInstructionData
> {
  return combineCodec(
    getBridgeWrappedTokenInstructionDataEncoder(),
    getBridgeWrappedTokenInstructionDataDecoder()
  );
}

export type BridgeWrappedTokenInput<
  TAccountPayer extends string = string,
  TAccountFrom extends string = string,
  TAccountGasFeeReceiver extends string = string,
  TAccountMint extends string = string,
  TAccountFromTokenAccount extends string = string,
  TAccountBridge extends string = string,
  TAccountOutgoingMessage extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  /**
   * The account that pays for transaction fees and outgoing message account creation.
   * Must be mutable to deduct lamports for account rent and gas fees.
   */
  payer: TransactionSigner<TAccountPayer>;
  /**
   * The token owner who is bridging their wrapped tokens back to Base.
   * Must sign the transaction to authorize burning their tokens.
   */
  from: TransactionSigner<TAccountFrom>;
  /** The account that receives payment for the gas costs of bridging the token on Base. */
  gasFeeReceiver: Address<TAccountGasFeeReceiver>;
  /**
   * The wrapped token mint account representing the original Base token.
   * - Contains metadata linking to the original token on Base
   * - Tokens will be burned from this mint
   */
  mint: Address<TAccountMint>;
  /**
   * The user's token account holding the wrapped tokens to be bridged.
   * - Must contain sufficient token balance for the bridge amount
   * - Tokens will be burned from this account
   */
  fromTokenAccount: Address<TAccountFromTokenAccount>;
  /**
   * The main bridge state account storing global bridge configuration.
   * - Uses PDA with BRIDGE_SEED for deterministic address
   * - Tracks nonce for message ordering and EIP-1559 gas pricing
   */
  bridge: Address<TAccountBridge>;
  /**
   * The outgoing message account being created to store bridge transfer data.
   * - Contains transfer details and optional call data for Base execution
   * - Space allocated based on call data size
   * - Will be read by Base relayers to complete the bridge operation
   */
  outgoingMessage: Address<TAccountOutgoingMessage>;
  /**
   * Token2022 program used for burning the wrapped tokens.
   * Required for all token operations including burn_checked.
   */
  tokenProgram?: Address<TAccountTokenProgram>;
  /**
   * System program required for creating the outgoing message account
   * and transferring the gas payment to the `gas_fee_receiver`.
   */
  systemProgram?: Address<TAccountSystemProgram>;
  outgoingMessageSalt: BridgeWrappedTokenInstructionDataArgs['outgoingMessageSalt'];
  to: BridgeWrappedTokenInstructionDataArgs['to'];
  amount: BridgeWrappedTokenInstructionDataArgs['amount'];
  call: BridgeWrappedTokenInstructionDataArgs['call'];
};

export function getBridgeWrappedTokenInstruction<
  TAccountPayer extends string,
  TAccountFrom extends string,
  TAccountGasFeeReceiver extends string,
  TAccountMint extends string,
  TAccountFromTokenAccount extends string,
  TAccountBridge extends string,
  TAccountOutgoingMessage extends string,
  TAccountTokenProgram extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof BRIDGE_PROGRAM_ADDRESS,
>(
  input: BridgeWrappedTokenInput<
    TAccountPayer,
    TAccountFrom,
    TAccountGasFeeReceiver,
    TAccountMint,
    TAccountFromTokenAccount,
    TAccountBridge,
    TAccountOutgoingMessage,
    TAccountTokenProgram,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress }
): BridgeWrappedTokenInstruction<
  TProgramAddress,
  TAccountPayer,
  TAccountFrom,
  TAccountGasFeeReceiver,
  TAccountMint,
  TAccountFromTokenAccount,
  TAccountBridge,
  TAccountOutgoingMessage,
  TAccountTokenProgram,
  TAccountSystemProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? BRIDGE_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    from: { value: input.from ?? null, isWritable: false },
    gasFeeReceiver: { value: input.gasFeeReceiver ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: true },
    fromTokenAccount: {
      value: input.fromTokenAccount ?? null,
      isWritable: true,
    },
    bridge: { value: input.bridge ?? null, isWritable: true },
    outgoingMessage: { value: input.outgoingMessage ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.from),
      getAccountMeta(accounts.gasFeeReceiver),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.fromTokenAccount),
      getAccountMeta(accounts.bridge),
      getAccountMeta(accounts.outgoingMessage),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
    ],
    programAddress,
    data: getBridgeWrappedTokenInstructionDataEncoder().encode(
      args as BridgeWrappedTokenInstructionDataArgs
    ),
  } as BridgeWrappedTokenInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountFrom,
    TAccountGasFeeReceiver,
    TAccountMint,
    TAccountFromTokenAccount,
    TAccountBridge,
    TAccountOutgoingMessage,
    TAccountTokenProgram,
    TAccountSystemProgram
  >;

  return instruction;
}

export type ParsedBridgeWrappedTokenInstruction<
  TProgram extends string = typeof BRIDGE_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /**
     * The account that pays for transaction fees and outgoing message account creation.
     * Must be mutable to deduct lamports for account rent and gas fees.
     */

    payer: TAccountMetas[0];
    /**
     * The token owner who is bridging their wrapped tokens back to Base.
     * Must sign the transaction to authorize burning their tokens.
     */

    from: TAccountMetas[1];
    /** The account that receives payment for the gas costs of bridging the token on Base. */
    gasFeeReceiver: TAccountMetas[2];
    /**
     * The wrapped token mint account representing the original Base token.
     * - Contains metadata linking to the original token on Base
     * - Tokens will be burned from this mint
     */

    mint: TAccountMetas[3];
    /**
     * The user's token account holding the wrapped tokens to be bridged.
     * - Must contain sufficient token balance for the bridge amount
     * - Tokens will be burned from this account
     */

    fromTokenAccount: TAccountMetas[4];
    /**
     * The main bridge state account storing global bridge configuration.
     * - Uses PDA with BRIDGE_SEED for deterministic address
     * - Tracks nonce for message ordering and EIP-1559 gas pricing
     */

    bridge: TAccountMetas[5];
    /**
     * The outgoing message account being created to store bridge transfer data.
     * - Contains transfer details and optional call data for Base execution
     * - Space allocated based on call data size
     * - Will be read by Base relayers to complete the bridge operation
     */

    outgoingMessage: TAccountMetas[6];
    /**
     * Token2022 program used for burning the wrapped tokens.
     * Required for all token operations including burn_checked.
     */

    tokenProgram: TAccountMetas[7];
    /**
     * System program required for creating the outgoing message account
     * and transferring the gas payment to the `gas_fee_receiver`.
     */

    systemProgram: TAccountMetas[8];
  };
  data: BridgeWrappedTokenInstructionData;
};

export function parseBridgeWrappedTokenInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedBridgeWrappedTokenInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 9) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      from: getNextAccount(),
      gasFeeReceiver: getNextAccount(),
      mint: getNextAccount(),
      fromTokenAccount: getNextAccount(),
      bridge: getNextAccount(),
      outgoingMessage: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
    },
    data: getBridgeWrappedTokenInstructionDataDecoder().decode(
      instruction.data
    ),
  };
}
